global proc shelf_Playcanvas () {
    global string $gBuffStr;
    global string $gBuffStr0;
    global string $gBuffStr1;


    shelfButton
        -enableCommandRepeat 1
        -enable 1
        -width 35
        -height 35
        -manage 1
        -visible 1
        -preventOverride 0
        -annotation "Sets animation settings for Playcanvas assets" 
        -enableBackground 0
        -backgroundColor 0 0 0 
        -highlightColor 0.321569 0.521569 0.65098 
        -align "center" 
        -label "/////////////////////\n//Set FPS and Key Interpolation for Playca..." 
        -labelOffset 0
        -rotation 0
        -flipX 0
        -flipY 0
        -useAlpha 1
        -font "plainLabelFont" 
        -imageOverlayLabel "PCsetup" 
        -overlayLabelColor 0.8 0.8 0.8 
        -overlayLabelBackColor 0 0 0 0.5 
        -image "C:/Users/jef/Documents/maya/2016/prefs/icons/playcanvas_inverse_logo.png" 
        -image1 "C:/Users/jef/Documents/maya/2016/prefs/icons/playcanvas_inverse_logo.png" 
        -style "iconOnly" 
        -marginWidth 1
        -marginHeight 1
        -command "/////////////////////\n//Set FPS and Key Interpolation for Playcanvas\n/////////////////////\ncurrentUnit -t ntscf;\nkeyTangent -global -itt linear -ott linear;\n//Sets playback bar to 1\nplaybackOptions -e -min 1 -max 300 -ast 1 -aet 500;\n//sets playback to frame start\nplayButtonStart;" 
        -sourceType "mel" 
        -commandRepeatable 1
        -flat 1
    ;
    shelfButton
        -enableCommandRepeat 1
        -enable 1
        -width 35
        -height 35
        -manage 1
        -visible 1
        -preventOverride 0
        -annotation "creates JSON file and FBX file to be used in Playcanvas" 
        -enableBackground 0
        -backgroundColor 0 0 0 
        -highlightColor 0.321569 0.521569 0.65098 
        -align "center" 
        -label "//create file dialog for output folder\nstring $outputFolder[] = ..." 
        -labelOffset 0
        -rotation 0
        -flipX 0
        -flipY 0
        -useAlpha 1
        -font "plainLabelFont" 
        -overlayLabelColor 0.8 0.8 0.8 
        -overlayLabelBackColor 0 0 0 0.5 
        -image "C:/Users/jef/Documents/maya/2016/prefs/icons/maya2playcanvas_icon4.png" 
        -image1 "C:/Users/jef/Documents/maya/2016/prefs/icons/maya2playcanvas_icon4.png" 
        -style "iconOnly" 
        -marginWidth 1
        -marginHeight 1
        -command "//create file dialog for output folder\nstring $outputFolder[] = `fileDialog2 -ds 1 -fm 3 -cap \"Output File To:\"`;\n\n\nif (size($outputFolder)>0)\n{\n//start timer\nstring $timerName = `timer -s`;\n\n\n//get selection\nstring $myObj[] = `ls -sl`;\n\n\n//get FPS\nfloat $fps = `currentTimeUnitToFPS`;\n\n\n//create string array and fill it with only the selected objects that have animation\nstring $animatedObjects[];\nclear $animatedObjects;\nfor ($m in $myObj)\n{\n    float $hasKeys[] = `keyframe -at rx -at ry -at rz -at tx -at ty -at tz -at sx -at sy -at sz -q $m`;\n    \n    float $hasTKeys[] = `keyframe -at tx -at ty -at tz -q $m`;\n    float $hasRKeys[] = `keyframe -at rx -at ry -at rz -q $m`;\n    float $hasSKeys[] = `keyframe -at sx -at sy -at sz -q $m`;\n    \n    int $tanimated = 0;\n    int $ranimated = 0;\n    int $sanimated = 0;\n\n    //////////////////////////////////\n    //Check if translate has animation\n    //////////////////////////////////\n    if (size($hasTKeys) > 0)\n    {\n    \n    string $translateXAttrName = ($m + \".translateX\");\n    string $translateYAttrName = ($m + \".translateY\"); \n    string $translateZAttrName = ($m + \".translateZ\");\n    \n    float $txCurrent;\n    float $tyCurrent;\n    float $tzCurrent;\n    \n    float $txNew;\n    float $tyNew;\n    float $tzNew;\n    \n    float $txVals[] = `keyframe -q -r -vc $translateXAttrName`;\n    int $txValsSize = size($txVals);\n    float $tyVals[] = `keyframe -q -r -vc $translateYAttrName`;\n    int $tyValsSize = size($tyVals);\n    float $tzVals[] = `keyframe -q -r -vc $translateZAttrName`;\n    int $tzValsSize = size($tzVals);\n\n    int $txAnimated = 0;\n    int $tyAnimated = 0;\n    int $tzAnimated = 0;    \n        \n        //translate X\n        if ($txValsSize > 0)\n        {\n            //loop through keys\n            for ($tx=0; $tx<$txValsSize; ++$tx)\n            {\n                $txNew = $txVals[$tx];\n                \n                if ($tx == 0)\n                {\n                    $txCurrent = $txNew;\n                }\n                else if ($txNew != $txCurrent)\n                {\n                    $txAnimated = 1;\n                    $txCurrent = $txNew;\n                }\n                else\n                {\n                    $txCurrent = $txNew;\n                }\n            }\n        }\n           //translate Y\n        if ($tyValsSize > 0)\n        {\n            //loop through keys\n            for ($ty=0; $ty<$tyValsSize; ++$ty)\n            {\n                $tyNew = $tyVals[$ty];\n                \n                if ($ty == 0)\n                {\n                    $tyCurrent = $tyNew;\n                }\n                else if ($tyNew != $tyCurrent)\n                {\n                    $tyAnimated = 1;\n                    $tyCurrent = $tyNew;\n                }\n                else\n                {\n                    $tyCurrent = $tyNew;\n                }\n            }\n        }\n           //translate Z\n        if ($tzValsSize > 0)\n        {\n            //loop through keys\n            for ($tz=0; $tz<$tzValsSize; ++$tz)\n            {\n                $tzNew = $tzVals[$tz];\n                \n                if ($tz == 0)\n                {\n                    $tzCurrent = $tzNew;\n                }\n                else if ($tzNew != $tzCurrent)\n                {\n                    $tzAnimated = 1;\n                    $tzCurrent = $tzNew;\n                }\n                else\n                {\n                    $tzCurrent = $tzNew;\n                }\n            }\n        }\n    \n    $tanimated = $txAnimated + $tyAnimated + $tzAnimated;\n    }\n\n    //////////////////////////////////\n    //Check if rotate has animation\n    //////////////////////////////////\n    if (size($hasRKeys) > 0)\n    {\n    \n    string $rotateXAttrName = ($m + \".rotateX\");\n    string $rotateYAttrName = ($m + \".rotateY\"); \n    string $rotateZAttrName = ($m + \".rotateZ\");\n    \n    float $rxCurrent;\n    float $ryCurrent;\n    float $rzCurrent;\n    \n    float $rxNew;\n    float $ryNew;\n    float $rzNew;\n    \n    float $rxVals[] = `keyframe -q -r -vc $rotateXAttrName`;\n    int $rxValsSize = size($rxVals);\n    float $ryVals[] = `keyframe -q -r -vc $rotateYAttrName`;\n    int $ryValsSize = size($ryVals);\n    float $rzVals[] = `keyframe -q -r -vc $rotateZAttrName`;\n    int $rzValsSize = size($rzVals);\n\n    int $rxAnimated = 0;\n    int $ryAnimated = 0;\n    int $rzAnimated = 0;\n        \n        //rotate X\n        if ($rxValsSize > 0)\n        {\n            //loop through keys\n            for ($rx=0; $rx<$rxValsSize; ++$rx)\n            {\n                $rxNew = $rxVals[$rx];\n                \n                if ($rx == 0)\n                {\n                    $rxCurrent = $rxNew;\n                }\n                else if ($rxNew != $rxCurrent)\n                {\n                    $rxAnimated = 1;\n                    $rxCurrent = $rxNew;\n                }\n                else\n                {\n                    $rxCurrent = $rxNew;\n                }\n            }\n        }\n           //rotate Y\n        if ($ryValsSize > 0)\n        {\n            //loop through keys\n            for ($ry=0; $ry<$ryValsSize; ++$ry)\n            {\n                $ryNew = $ryVals[$ry];\n                \n                if ($ry == 0)\n                {\n                    $ryCurrent = $ryNew;\n                }\n                else if ($ryNew != $ryCurrent)\n                {\n                    $ryAnimated = 1;\n                    $ryCurrent = $ryNew;\n                }\n                else\n                {\n                    $ryCurrent = $ryNew;\n                }\n            }\n        }\n           //rotate Z\n        if ($rzValsSize > 0)\n        {\n            //loop through keys\n            for ($rz=0; $rz<$rzValsSize; ++$rz)\n            {\n                $rzNew = $rzVals[$rz];\n                \n                if ($rz == 0)\n                {\n                    $rzCurrent = $rzNew;\n                }\n                else if ($rzNew != $rzCurrent)\n                {\n                    $rzAnimated = 1;\n                    $rzCurrent = $rzNew;\n                }\n                else\n                {\n                    $rzCurrent = $rzNew;\n                }\n            }\n        }\n    \n    $ranimated = $rxAnimated + $ryAnimated + $rzAnimated;\n    }\n\n    //////////////////////////////////\n    //Check if scale has animation\n    //////////////////////////////////\n    if (size($hasSKeys) > 0)\n    {\n    \n    string $scaleXAttrName = ($m + \".scaleX\");\n    string $scaleYAttrName = ($m + \".scaleY\"); \n    string $scaleZAttrName = ($m + \".scaleZ\");\n    \n    float $sxCurrent;\n    float $syCurrent;\n    float $szCurrent;\n    \n    float $sxNew;\n    float $syNew;\n    float $szNew;\n    \n    float $sxVals[] = `keyframe -q -r -vc $scaleXAttrName`;\n    int $sxValsSize = size($sxVals);\n    float $syVals[] = `keyframe -q -r -vc $scaleYAttrName`;\n    int $syValsSize = size($syVals);\n    float $szVals[] = `keyframe -q -r -vc $scaleZAttrName`;\n    int $szValsSize = size($szVals);\n\n    int $sxAnimated = 0;\n    int $syAnimated = 0;\n    int $szAnimated = 0;\n        \n        //scale X\n        if ($sxValsSize > 0)\n        {\n            //loop through keys\n            for ($sx=0; $sx<$sxValsSize; ++$sx)\n            {\n                $sxNew = $sxVals[$sx];\n                \n                if ($sx == 0)\n                {\n                    $sxCurrent = $sxNew;\n                }\n                else if ($sxNew != $sxCurrent)\n                {\n                    $sxAnimated = 1;\n                    $sxCurrent = $sxNew;\n                }\n                else\n                {\n                    $sxCurrent = $sxNew;\n                }\n            }\n        }\n           //scale Y\n        if ($syValsSize > 0)\n        {\n            //loop through keys\n            for ($sy=0; $sy<$syValsSize; ++$sy)\n            {\n                $syNew = $syVals[$sy];\n                \n                if ($sy == 0)\n                {\n                    $syCurrent = $syNew;\n                }\n                else if ($syNew != $syCurrent)\n                {\n                    $syAnimated = 1;\n                    $syCurrent = $syNew;\n                }\n                else\n                {\n                    $syCurrent = $syNew;\n                }\n            }\n        }\n           //scale Z\n        if ($szValsSize > 0)\n        {\n            //loop through keys\n            for ($sz=0; $sz<$szValsSize; ++$sz)\n            {\n                $szNew = $szVals[$sz];\n                \n                if ($sz == 0)\n                {\n                    $szCurrent = $szNew;\n                }\n                else if ($szNew != $szCurrent)\n                {\n                    $szAnimated = 1;\n                    $szCurrent = $szNew;\n                }\n                else\n                {\n                    $szCurrent = $szNew;\n                }\n            }\n        }\n    \n    $sanimated = $sxAnimated + $syAnimated + $szAnimated;\n    }\n    \n    //create variable to tell if there is any animation\n    int $animated = $tanimated + $ranimated + $sanimated;\n\n    if ($animated > 0)\n    {\n        $animatedObjects[size($animatedObjects)] = $m;        \n    }\n} //end loop to create array of animated objects\n\n//find first and last frames of all animation of selected objects\nfloat $lastKeyframe;\nfloat $firstKeyframe;\nfloat $currentLastKeyframe;\nfloat $currentFirstKeyframe;\nfor( $n=0; $n<size($animatedObjects); ++$n )\n{\n    $currentLastKeyframe = `findKeyframe -w last $animatedObjects[$n]`;\n    $currentFirstKeyframe = `findKeyframe -w first $animatedObjects[$n]`;\n    \n    //set first and last keyframe first time through loop    \n    if ($n == 0)\n    {\n        $firstKeyframe = $currentFirstKeyframe;\n        $lastKeyframe = $currentLastKeyframe;\n    }\n    //set first keyframe to earliest and last keyframe to latest\n    else\n    {\n        if ($firstKeyframe > $currentFirstKeyframe)\n        {\n            $firstKeyframe = $currentFirstKeyframe;\n        }\n        if ($lastKeyframe < $currentLastKeyframe)\n        {\n            $lastKeyframe = $currentLastKeyframe;\n        }\n    }\n    \n}\n\n\n//find duration using first and last keyframes set above\nfloat $duration = ($lastKeyframe - $firstKeyframe)/$fps;\n\n\n//check selection\nif (size($myObj) == 0)\n{\nconfirmDialog -title \"You're givin' me nuthin here!\"\n    -message \"No object is selected. Select one or more objects with animation, then run the script again to create Playcanvas .json animation file.\"\n    -button \"Ok\";\ntimer -e; \n}\n\n\nelse if (size($animatedObjects) == 0)\n{\nconfirmDialog -title \"You're givin' me nuthin here!\"\n    -message \"No selected object has animation. Select one or more objects with animation, then run the script again to create Playcanvas .json animation file.\"\n    -button \"Ok\";\ntimer -e;\n}\n\n\n//main script\nelse\n{\n\n\n//create string for file output and write header of json file\nstring $fileContent = \"{\\\"animation\\\":{\\\"version\\\":4,\\\"name\\\":\\\"Take 001\\\",\\\"duration\\\":\" + $duration + \",\\\"nodes\\\":[\" + \"\\n\";  \n\n\n//create helper locator to store rotation values\nstring $helperLocator[] = `spaceLocator -name \"helperLocator\"`;\n\n\n//loop for each object selected that has animation\nint $objectIndex = 0;\nfor ($j in $animatedObjects)\n{\n    //delete (non deformer) history on object\n    //delete -ch $j;\n    //bakePartialHistory -pre $j;\n\n\n    //find beginning and ending frames of animation on object\n    float $lastKey = `findKeyframe -animation keysOrObjects -w last $j`;\n    float $firstKey = `findKeyframe -animation keysOrObjects -w first $j`;\n\n\n    //get frames of all keys on object\n    float $keyframeTimesTemp[] = `keyframe -at rx -at ry -at rz -at tx -at ty -at tz -at sx -at sy -at sz -q $j`;\n    //put frames in ascending order\n    float $sortedKeys[] = `sort $keyframeTimesTemp`;\n    //create new variable to hold final list of frames that have keyframes\n    float $finalKeyList[];\n    //create loop to add non-duplicates to $finalKeyList to finilize list of frames that have keyframes\n    int $sortedKeysSize = `size($sortedKeys)`;\n    for( $i=0; $i<$sortedKeysSize; ++$i )\n        {\n            if ($i == 0)\n               {\n                    $finalKeyList[size($finalKeyList)] = $sortedKeys[$i];\n                }\n            else if ($sortedKeys[$i] != $sortedKeys[$i - 1])\n                {\n                    $finalKeyList[size($finalKeyList)] = $sortedKeys[$i];\n                }\n        }\n    //get number of keys on object    \n    int $keySize = `size($finalKeyList)`;\n\n\n    //find object's parent and helper locator's current parent\n    string $objectParent[] = `listRelatives -parent $j`;\n    string $locParent[] = `listRelatives -parent $helperLocator[0]`;\n    \n    //put helper locator under object's parent\n    if ($objectParent[0] != $locParent[0])\n    {\n        parent $helperLocator[0] $objectParent[0];\n    }\n    \n    //constrain helper locator to object\n    string $orientConstName[] = `orientConstraint $j $helperLocator[0]`;\n    string $pointConstName[] = `pointConstraint $j $helperLocator[0]`; \n\n\n    //Put key values into float arrays\n    float $translateXkeyVals[];\n    float $translateYkeyVals[];\n    float $translateZkeyVals[];\n    \n    float $rotateXkeyVals[];\n    float $rotateYkeyVals[];\n    float $rotateZkeyVals[];\n    \n    float $scaleXkeyVals[];\n    float $scaleYkeyVals[];\n    float $scaleZkeyVals[];\n    \n    float $keyTime[];\n    \n    //loop for each keyframe\n    for( $i=0; $i<$keySize; ++$i )\n        {\n            //adjust current time so parent constraint updates\n            currentTime $finalKeyList[$i];\n\n\n            string $TXattrName = $helperLocator[0] + \".translateX\";\n            $translateXkeyVals[$i] = `getAttr -t $finalKeyList[$i] $TXattrName`;\n            string $TYattrName = $helperLocator[0] + \".translateY\";\n            $translateYkeyVals[$i] = `getAttr -t $finalKeyList[$i] $TYattrName`;\n            string $TZattrName = $helperLocator[0] + \".translateZ\";\n            $translateZkeyVals[$i] = `getAttr -t $finalKeyList[$i] $TZattrName`;\n          \n            string $RXattrName = $helperLocator[0] + \".rotateX\";\n            $rotateXkeyVals[$i] = `getAttr -t $finalKeyList[$i] $RXattrName`;\n            string $RYattrName = $helperLocator[0] + \".rotateY\";\n            $rotateYkeyVals[$i] = `getAttr -t $finalKeyList[$i] $RYattrName`;\n            string $RZattrName = $helperLocator[0] + \".rotateZ\";\n            $rotateZkeyVals[$i] = `getAttr -t $finalKeyList[$i] $RZattrName`;\n                        \n            string $SXattrName = $j + \".scaleX\";\n            $scaleXkeyVals[$i] = `getAttr -t $finalKeyList[$i] $SXattrName`;\n            string $SYattrName = $j + \".scaleY\";\n            $scaleYkeyVals[$i] = `getAttr -t $finalKeyList[$i] $SYattrName`;\n            string $SZattrName = $j + \".scaleZ\";\n            $scaleZkeyVals[$i] = `getAttr -t $finalKeyList[$i] $SZattrName`; \n            \n            //convert frame numbers of keys to seconds and put them into array\n            $keyTime[$i] = $finalKeyList[$i]/$fps;     \n            \n        }\n    \n    //delete parent constraint on helper locator so it can be constrained to next object\n    delete $orientConstName;\n    delete $pointConstName;\n    \n    //make object name into one playcanvas understands (makes names non unique)\n    string $objectNameStringSplit[];\n    int $numTokens = `tokenize $j \"|\" $objectNameStringSplit`;\n    string $niceName = $objectNameStringSplit[($numTokens - 1)];\n    \n    //add object name to ouptput string\n    $fileContent = $fileContent + \"{\\\"name\\\":\\\"\" + $niceName + \"\\\",\\\"defaults\\\":{\";\n    \n    //find which attributes have animation curves\n    string $connex[] = `listConnections -d off -s on $j`;\n    int $tmatch = 0;\n    int $rmatch = 0;\n    int $smatch = 0;\n    for ($curves in $connex)\n    {\n        $tmatchPre = `gmatch $curves \"*translate*\"`;\n        $rmatchPre = `gmatch $curves \"*rotate*\"`;\n        $smatchPre = `gmatch $curves \"*scale*\"`;\n    \n        if ($tmatchPre == 1)\n            {\n                $tmatch = 1;\n            }\n        if ($rmatchPre == 1)\n            {\n                $rmatch = 1;\n            }    \n        if ($smatchPre == 1)\n            {\n                $smatch = 1;\n            }\n    }\n//check to make sure animation curves have a change in value\n\n\n////////////////////////\n//Check if Translate has actual animation\n///////////////////////\nint $isAnimatedT = 0;\nif ($tmatch == 1)\n    {\n        int $isAnimatedTX = 0;\n        int $isAnimatedTY = 0;\n        int $isAnimatedTZ = 0;\n        string $attrXName = $animatedObjects[$objectIndex] + \".translateX\";\n        string $attrYName = $animatedObjects[$objectIndex] + \".translateY\";\n        string $attrZName = $animatedObjects[$objectIndex] + \".translateZ\";\n        float $keyValsTX[] = `keyframe -q -r -vc $attrXName`;\n        float $keyValsTY[] = `keyframe -q -r -vc $attrYName`;\n        float $keyValsTZ[] = `keyframe -q -r -vc $attrZName`;\n        float $currentValX;\n        float $currentValY;\n        float $currentValZ;\n        \n        int $keyValTXSize = size($keyValsTX);\n        int $keyValTYSize = size($keyValsTY);\n        int $keyValTZSize = size($keyValsTZ);\n        \n        for( $i=0; $i<$keyValTXSize; ++$i )\n        {\n          //this will compare the values to the previous keyframe and if there is a change it will make isAnimated = 1\n          //so a static value will be placed in \"defaults\" instead of set as keyframe data in the json file output\n          if ($i==0)\n          {\n              $currentValX = $keyValsTX[0];\n          }\n          else if ($keyValsTX[$i] != $currentValX)\n          {\n              $isAnimatedTX = 1;\n              $currentValX = $keyValsTX[$i];\n          }\n          else\n          {\n              $currentValX = $keyValsTX[$i];\n          }\n          \n        }\n                \n         for( $i=0; $i<$keyValTYSize; ++$i )\n        {\n          //this will compare the values to the previous keyframe and if there is a change it will make isAnimated = 1\n          //so a static value will be placed in \"defaults\" instead of set as keyframe data in the json file output\n          if ($i==0)\n          {\n              $currentValY = $keyValsTY[0];\n          }\n          else if ($keyValsTY[$i] != $currentValY)\n          {\n              $isAnimatedTY = 1;\n              $currentValY = $keyValsTY[$i];\n          }\n          else\n          {\n              $currentValY = $keyValsTY[$i];\n          }\n          \n        } \n                 \n         for( $i=0; $i<$keyValTZSize; ++$i )\n        {\n          //this will compare the values to the previous keyframe and if there is a change it will make isAnimated = 1\n          //so a static value will be placed in \"defaults\" instead of set as keyframe data in the json file output\n          if ($i==0)\n          {\n              $currentValZ = $keyValsTZ[0];\n          }\n          else if ($keyValsTZ[$i] != $currentValZ)\n          {\n              $isAnimatedTZ = 1;\n              $currentValZ = $keyValsTZ[$i];\n          }\n          else\n          {\n              $currentValZ = $keyValsTZ[$i];\n          }\n          \n        }\n                \n        //add up all the $isAnimated to see if there is any animation on any of the three \n        int $isAnimatedT = ($isAnimatedTX + $isAnimatedTY + $isAnimatedTZ);\n        if ($isAnimatedT == 0)\n        {\n            $tmatch = 0;\n            print (\"There is no animation on Translate on \" + $animatedObjects[$objectIndex] + \"\\n\");\n        }\n        else if ($isAnimatedT > 0)\n        {\n            $tmatch = 1;\n            print (\"Translate has animation on \" + $animatedObjects[$objectIndex] + \"\\n\");\n        }\n    }\n////////////////////////\n//Check if Rotate has actual animation\n///////////////////////\nint $isAnimatedR = 0;\nif ($rmatch == 1)\n    {\n        int $isAnimatedRX = 0;\n        int $isAnimatedRY = 0;\n        int $isAnimatedRZ = 0;\n        string $attrRXName = $animatedObjects[$objectIndex] + \".rotateX\";\n        string $attrRYName = $animatedObjects[$objectIndex] + \".rotateY\";\n        string $attrRZName = $animatedObjects[$objectIndex] + \".rotateZ\";\n        float $keyValsRX[] = `keyframe -q -r -vc $attrRXName`;\n        float $keyValsRY[] = `keyframe -q -r -vc $attrRYName`;\n        float $keyValsRZ[] = `keyframe -q -r -vc $attrRZName`;\n        float $currentValRX;\n        float $currentValRY;\n        float $currentValRZ;\n        \n        int $keyValRXSize = size($keyValsRX);\n        int $keyValRYSize = size($keyValsRY);\n        int $keyValRZSize = size($keyValsRZ);\n        \n        for( $i=0; $i<$keyValRXSize; ++$i )\n        {\n          //this will compare the values to the previous keyframe and if there is a change it will make isAnimated = 1\n          //so a static value will be placed in \"defaults\" instead of set as keyframe data in the json file output\n          if ($i==0)\n          {\n              $currentValRX = $keyValsRX[0];\n          }\n          else if ($keyValsRX[$i] != $currentValRX)\n          {\n              $isAnimatedRX = 1;\n              $currentValRX = $keyValsRX[$i];\n          }\n          else\n          {\n              $currentValRX = $keyValsRX[$i];\n          }\n          \n        }\n                \n         for( $i=0; $i<$keyValRYSize; ++$i )\n        {\n          //this will compare the values to the previous keyframe and if there is a change it will make isAnimated = 1\n          //so a static value will be placed in \"defaults\" instead of set as keyframe data in the json file output\n          if ($i==0)\n          {\n              $currentValRY = $keyValsRY[0];\n          }\n          else if ($keyValsRY[$i] != $currentValRY)\n          {\n              $isAnimatedRY = 1;\n              $currentValRY = $keyValsRY[$i];\n          }\n          else\n          {\n              $currentValRY = $keyValsRY[$i];\n          }\n          \n        } \n                 \n         for( $i=0; $i<$keyValRZSize; ++$i )\n        {\n          //this will compare the values to the previous keyframe and if there is a change it will make isAnimated = 1\n          //so a static value will be placed in \"defaults\" instead of set as keyframe data in the json file output\n          if ($i==0)\n          {\n              $currentValRZ = $keyValsRZ[0];\n          }\n          else if ($keyValsRZ[$i] != $currentValRZ)\n          {\n              $isAnimatedRZ = 1;\n              $currentValRZ = $keyValsRZ[$i];\n          }\n          else\n          {\n              $currentValRZ = $keyValsRZ[$i];\n          }\n          \n        }\n                \n        //add up all the $isAnimated to see if there is any animation on any of the three \n        int $isAnimatedR = ($isAnimatedRX + $isAnimatedRY + $isAnimatedRZ);\n        if ($isAnimatedR == 0)\n        {\n            $rmatch = 0;\n            print (\"There is no animation on Rotate on \" + $animatedObjects[$objectIndex] + \"\\n\");\n        }\n        else if ($isAnimatedR > 0)\n        {\n            $rmatch = 1;\n            print (\"Rotate has animation on \" + $animatedObjects[$objectIndex] + \"\\n\");\n        }\n    }\n\n\n////////////////////////\n//Check if Scale has actual animation\n///////////////////////\nint $isAnimatedS = 0;\nif ($smatch == 1)\n    {\n        int $isAnimatedSX = 0;\n        int $isAnimatedSY = 0;\n        int $isAnimatedSZ = 0;\n        string $attrSXName = $animatedObjects[$objectIndex] + \".scaleX\";\n        string $attrSYName = $animatedObjects[$objectIndex] + \".scaleY\";\n        string $attrSZName = $animatedObjects[$objectIndex] + \".scaleZ\";\n        float $keyValsSX[] = `keyframe -q -r -vc $attrSXName`;\n        float $keyValsSY[] = `keyframe -q -r -vc $attrSYName`;\n        float $keyValsSZ[] = `keyframe -q -r -vc $attrSZName`;\n        float $currentValSX;\n        float $currentValSY;\n        float $currentValSZ;\n        \n        int $keyValSXSize = size($keyValsSX);\n        int $keyValSYSize = size($keyValsSY);\n        int $keyValSZSize = size($keyValsSZ);\n        \n        for( $i=0; $i<$keyValSXSize; ++$i )\n        {\n          //this will compare the values to the previous keyframe and if there is a change it will make isAnimated = 1\n          //so a static value will be placed in \"defaults\" instead of set as keyframe data in the json file output\n          if ($i==0)\n          {\n              $currentValSX = $keyValsSX[0];\n          }\n          else if ($keyValsSX[$i] != $currentValSX)\n          {\n              $isAnimatedSX = 1;\n              $currentValSX = $keyValsSX[$i];\n          }\n          else\n          {\n              $currentValSX = $keyValsSX[$i];\n          }\n          \n        }\n                \n         for( $i=0; $i<$keyValSYSize; ++$i )\n        {\n          //this will compare the values to the previous keyframe and if there is a change it will make isAnimated = 1\n          //so a static value will be placed in \"defaults\" instead of set as keyframe data in the json file output\n          if ($i==0)\n          {\n              $currentValSY = $keyValsSY[0];\n          }\n          else if ($keyValsSY[$i] != $currentValSY)\n          {\n              $isAnimatedSY = 1;\n              $currentValSY = $keyValsSY[$i];\n          }\n          else\n          {\n              $currentValSY = $keyValsSY[$i];\n          }\n          \n        } \n                 \n         for( $i=0; $i<$keyValSZSize; ++$i )\n        {\n          //this will compare the values to the previous keyframe and if there is a change it will make isAnimated = 1\n          //so a static value will be placed in \"defaults\" instead of set as keyframe data in the json file output\n          if ($i==0)\n          {\n              $currentValSZ = $keyValsSZ[0];\n          }\n          else if ($keyValsSZ[$i] != $currentValSZ)\n          {\n              $isAnimatedSZ = 1;\n              $currentValSZ = $keyValsSZ[$i];\n          }\n          else\n          {\n              $currentValSZ = $keyValsSZ[$i];\n          }\n          \n        }\n                \n        //add up all the $isAnimated to see if there is any animation on any of the three \n        int $isAnimatedS = ($isAnimatedSX + $isAnimatedSY + $isAnimatedSZ);\n        if ($isAnimatedS == 0)\n        {\n            $smatch = 0;\n            print (\"There is no animation on Scale on \" + $animatedObjects[$objectIndex] + \"\\n\");\n        }\n        else if ($isAnimatedS > 0)\n        {\n            $smatch = 1;\n            print (\"Scale has animation on \" + $animatedObjects[$objectIndex] + \"\\n\");\n        }\n    }\n\n\n    ///////////////////////////////////////////////////////////////////////////////\n    //add \"defaults\" into json output string according to what has animation curves\n    if ($tmatch == 0)\n    {\n        $fileContent = $fileContent + \"\\\"p\\\":[\" + $translateXkeyVals[0] + \",\" + $translateYkeyVals[0] + \",\" + $translateZkeyVals[0] + \"]\";\n        if (($rmatch + $smatch) < 2)\n            {\n                $fileContent = $fileContent + \",\";\n            }\n    }\n   \n    if ($rmatch == 0)\n    {\n        $fileContent = $fileContent + \"\\\"r\\\":[\" + $rotateXkeyVals[0] + \",\" + $rotateYkeyVals[0] + \",\" + $rotateZkeyVals[0] + \"]\";\n        if ($smatch == 0)\n            {\n                $fileContent = $fileContent + \",\";\n            }    \n    }\n    \n    if ($smatch == 0)\n    {\n         $fileContent = $fileContent + \"\\\"s\\\":[\" + $scaleXkeyVals[0] + \",\" + $scaleYkeyVals[0] + \",\" + $scaleZkeyVals[0] + \"]\";\n    }        \n        \n    //add rest of object header to output string up to keyframe data\n    $fileContent = $fileContent + \"},\" + \"\\n\" + \"\\\"keys\\\":[\";\n    \n    //write out keyframe values to file output string\n    for ( $p=0; $p<$keySize; ++$p )\n        {\n                $fileContent = $fileContent + \"{\\\"t\\\":\" + $keyTime[$p] + \",\";\n                if ($tmatch == 1)\n                {\n                    $fileContent = $fileContent + \"\\\"p\\\":[\" + $translateXkeyVals[$p] + \",\" + $translateYkeyVals[$p] + \",\" + $translateZkeyVals[$p] + \"]\";\n                    if (($rmatch + $smatch) > 0)\n                    {\n                        $fileContent = $fileContent + \",\";\n                    }\n                    if (($rmatch + $smatch) == 0)\n                    {\n                     if ($p == ($keySize - 1))\n                        {\n                            $fileContent = $fileContent + \"}\";\n                        }\n                        else\n                        {\n                            $fileContent = $fileContent + \"},\";\n                        }\n                    }  \n                }\n                if ($rmatch == 1)\n                {\n                    $fileContent = $fileContent + \"\\\"r\\\":[\" + $rotateXkeyVals[$p] + \",\" + $rotateYkeyVals[$p] + \",\" + $rotateZkeyVals[$p] + \"]\" + \"\\n\";\n                    if ($smatch == 1)\n                    {\n                        $fileContent = $fileContent + \",\";\n                    }\n                    else\n                    {\n                        if ($p == ($keySize - 1))\n                        {\n                            $fileContent = $fileContent + \"}\";\n                        }\n                        else\n                        {\n                            $fileContent = $fileContent + \"},\";\n                        }\n                    }\n                }\n                if ($smatch == 1)\n                {\n                    $fileContent = $fileContent + \"\\\"s\\\":[\" + $scaleXkeyVals[$p] + \",\" + $scaleYkeyVals[$p] + \",\" + $scaleZkeyVals[$p] + \"]\" + \"\\n\";\n                    \n                    if ($p == ($keySize - 1))\n                    {\n                        $fileContent = $fileContent + \"}\";\n                    }\n                    else\n                    {\n                        $fileContent = $fileContent + \"},\";\n                    }\n                        \n                }            \n        }\n        //add footer to object\n     if ($objectIndex == (size($animatedObjects)-1))\n     {\n         $fileContent = $fileContent + \"]}\" + \"\\n\";\n     }\n      if ($objectIndex < (size($animatedObjects)-1))\n     {\n         $fileContent = $fileContent + \"]},\" + \"\\n\";\n     }\n     $objectIndex = $objectIndex +1;\n\n\n//status update\nprint (\"finished \" + $objectIndex + \" of \" + size($animatedObjects) + \" objects.\\n\");\n\n\n} //end each object loop\n\n\n//add footer to output file string to finilize file content\n$fileContent = $fileContent + \"]}}\";\n\n\n///////////////////////////////////////////\n//start json export\nprint (\"Starting json output... \" + \"\\n\");\n\n\n//create output file name using scene name and first selected object\nstring $fullSceneName = `file -q -sn -shn`;\nstring $sceneName[];\ntokenize $fullSceneName \".\" $sceneName;\nstring $firstObjectName[];\ntokenize $animatedObjects[0] \"|\" $firstObjectName;\nstring $fileName = ($outputFolder[0] + \"/\" + $sceneName[0] + \"_\" + $firstObjectName[size($firstObjectName)-1] + \"_animation\" + \".json\");\n\n\n//write out file\n$fileId=`fopen $fileName \"w\"`;\nfprint $fileId $fileContent;\nfclose $fileId;\nprint (\"Completed json output.\" + \"\\n\");\n//delete helper locator\ndelete $helperLocator;\n\n\n////////////////////////////////////////////\n//start fbx export\nprint (\"Starting FBX output...\" + \"\\n\");\n\n\nselect -r $myObj;\nstring $FBXfileName = ($outputFolder[0] + \"/\" + $sceneName[0] + \"_\" + $firstObjectName[size($firstObjectName)-1] + \".fbx\");\nFBXExport -f $FBXfileName -s;\nprint (\"\\n\" + \"Completed FBX output.\" + \"\\n\" + \"Output Files to: \" + $outputFolder[0] + \"\\n\");\nclear $outputFolder;\n\n\n//end timer\nfloat $timeLength = `timer -e`;\nprint (\"Total Time: \" + $timeLength + \" Seconds\" + \"\\n\"); \n\n\n} //end main script (after selection check)\n} //end conditional (statement whether output folder was chosen);" 
        -sourceType "mel" 
        -commandRepeatable 1
        -flat 1
    ;
    shelfButton
        -enableCommandRepeat 1
        -enable 1
        -width 35
        -height 35
        -manage 1
        -visible 1
        -preventOverride 0
        -annotation "Renames Duplicate Nodes" 
        -enableBackground 0
        -backgroundColor 0 0 0 
        -highlightColor 0.321569 0.521569 0.65098 
        -align "center" 
        -label "import re\nfrom maya import cmds\ndef renameDuplicates():\n    #Fin..." 
        -labelOffset 0
        -rotation 0
        -flipX 0
        -flipY 0
        -useAlpha 1
        -font "plainLabelFont" 
        -overlayLabelColor 0.8 0.8 0.8 
        -overlayLabelBackColor 0 0 0 0.5 
        -image "C:/Users/jef/Documents/maya/2016/prefs/icons/renameDuplicates_icon2.png" 
        -image1 "C:/Users/jef/Documents/maya/2016/prefs/icons/renameDuplicates_icon2.png" 
        -style "iconOnly" 
        -marginWidth 1
        -marginHeight 1
        -command "import re\nfrom maya import cmds\ndef renameDuplicates():\n    #Find all objects that have the same shortname as another\n    #We can indentify them because they have | in the name\n    duplicates = [f for f in cmds.ls() if '|' in f]\n    #Sort them by hierarchy so that we don't rename a parent before a child.\n    duplicates.sort(key=lambda obj: obj.count('|'), reverse=True)\n     \n    #if we have duplicates, rename them\n    if duplicates:\n        for name in duplicates:\n            # extract the base name\n            m = re.compile(\"[^|]*$\").search(name) \n            shortname = m.group(0)\n \n            # extract the numeric suffix\n            m2 = re.compile(\".*[^0-9]\").match(shortname) \n            if m2:\n                stripSuffix = m2.group(0)\n            else:\n                stripSuffix = shortname\n             \n            #rename, adding '#' as the suffix, which tells maya to find the next available number\n            newname = cmds.rename(name, (stripSuffix + \"#\")) \n            print \"renamed %s to %s\" % (name, newname)\n             \n        return \"Renamed %s objects with duplicated name.\" % len(duplicates)\n    else:\n        return \"No Duplicates\"\n         \nrenameDuplicates()" 
        -sourceType "python" 
        -commandRepeatable 1
        -flat 1
    ;
    shelfButton
        -enableCommandRepeat 1
        -enable 1
        -width 35
        -height 35
        -manage 1
        -visible 1
        -preventOverride 0
        -annotation "Resets object pivot" 
        -enableBackground 0
        -backgroundColor 0 0 0 
        -highlightColor 0.321569 0.521569 0.65098 
        -align "center" 
        -label "/* This file downloaded from Highend3d.com\n''  \n''  Highend3d.co..." 
        -labelOffset 0
        -rotation 0
        -flipX 0
        -flipY 0
        -useAlpha 1
        -font "plainLabelFont" 
        -imageOverlayLabel "ResetPVT" 
        -overlayLabelColor 0.8 0.8 0.8 
        -overlayLabelBackColor 0 0 0 0.5 
        -image "C:/Users/jef/Documents/maya/2016/prefs/icons/resetPivot.xpm" 
        -image1 "C:/Users/jef/Documents/maya/2016/prefs/icons/resetPivot.xpm" 
        -style "iconOnly" 
        -marginWidth 1
        -marginHeight 1
        -command "/* This file downloaded from Highend3d.com\n''  \n''  Highend3d.com File Information:\n''  \n''    Script Name: resetPivot\n''    Author:  \n''    Last Updated: Dec 03, 2008\n''    Update/Change this file at:\n''    http://Highend3d.com/maya/downloads/mel_scripts/modeling/misc/2881.html\n''  \n''  Please do not alter any information above this line\n''  it is generated dynamically by Highend3d.com and will\n''  be changed automatically on any updates.\n*/\n// ///////////////////////////////////////////////////////////////\n// resetPivot.mel\n// version: 2.0.2\n//\n// Restores the \"real\" pivot position without the Local Pivot\n// offset wich occurs if you 1. freeze transform, 2. move the\n// pivot or 3. perform centerPivot on a transform.\n// Quite important when doing export to realtime 3D Engines.\n//\n// mar-04  eric    created\n// oct-04  eric    minor bugfix\n// jun-05  eric    fixed hierarchy stuff, added reordering\n// nov-07  eric    complete rewrite\n// apr-08  eric    minor bugfix & ezScriptInstaller-enabled\n// dec-08  eric    ezScriptInstaller-line removed, installs via droplet\n//\n// special thanks to:\n// Naughty Nathan (for the patience and your wicked test scene)\n// Anonymous Guy  (for creating the icon) (name to be replaced)\n//\n// ///////////////////////////////////////////////////////////////\n// goodsoul.de                            ewerybody@goodsoul.de //\n// //////////////////////////////////////////////////////////////\n\n// just to not create arrays if theres only 1 srtring\nproc string getArrayItem0(string $array[])\n{\n\treturn $array[0];\n}\n\n// to relocate potential animations from reseted obj and children\nproc relocateTransAnim(vector $currentPosition, string $object)\n{\n\tvector $posInTime = `getAttr -t (currentTime(\"-q\")) ($object + \".t\")`;\n\tif ($currentPosition != $posInTime)\n\t{\n\t\tvector $offset = ($currentPosition - $posInTime);\n\t\tkeyframe -e -iub true -r -o over -vc ($offset.x) ($object + \".translateX\");\n\t\tkeyframe -e -iub true -r -o over -vc ($offset.y) ($object + \".translateY\");\n\t\tkeyframe -e -iub true -r -o over -vc ($offset.z) ($object + \".translateZ\");\n\t}\n}\n\n// proc to get the position in the outlioner\nproc int reorderQ (string $object)\n{\n\tstring $shortName = match(\"[^|]*$\", $object);\n\tstring $parent = getArrayItem0(`listRelatives -f -p $object`);\n\t\n    string $siblings[]; // get all siblings\n    if ($parent != \"\") // if theres a parent\n\t\t$siblings = `listRelatives -f -c -type transform -type shape $parent`;\n    else // or if theres none\n\t\t$siblings = `ls -l -assemblies`;\n\n\tint $position = 0; // browse siblings\n    for ($sibling in $siblings)\n\t{\n        if (match(\"[^|]*$\", $sibling) != $shortName) //search $origObj in $siblings\n            $position++; //increase for each obj that isn't $object\n        else\n\t\t\treturn $position; // stop if found $origObj\n\t}\n}\n\nglobal proc resetPivot()\n{\n\tstring $sel[] = `ls -sl -l -transforms`;\n\tint $count = 1;\n\tfor ($obj in $sel)\n\t{\n\t\tstring $shortName = `match \"[^|]*$\" $obj`;\n\t\tvector $localPivot = `xform -q -rp $obj`;\n\t\tif ($localPivot != <<0.0, 0.0, 0.0>>)\n\t\t{\n\t\t\tprint(\"resetPivot (\" + $count + \"): \\\"\" + $shortName + \"\\\" has an offset of (\" + $localPivot.x + \") (\" + $localPivot.y + \") (\" + $localPivot.z + \")\\n\");\n\t\t\t\n\t\t\t//cut potential translation keys and take result for animation-check\n\t\t\tint $animCheck = `cutKey -at \"tx\" -at \"ty\" -at \"tz\" $obj`;\n\t\t\t\n\t\t\t// check if the object has children\n\t\t\tstring $children[] = `listRelatives -f -c -type \"transform\" $obj`;\n\t\t\tif (`size($children)`) // and parent them to the world\n\t\t\t\t$children = `parent -w $children`;\n\t\t\t\n\t\t\t// parent to world if not already\n\t\t\tstring $parent = getArrayItem0(`listRelatives -p -f $obj`);\n\t\t\tint $outlinerPosition;\n\t\t\tif ($parent != \"\")\n\t\t\t{\n\t\t\t\t$outlinerPosition = reorderQ($obj);\n\t\t\t\t$obj = getArrayItem0(`parent -w $obj`);\n\t\t\t}\n\n\t\t\t// get real world position\n\t\t\tvector $worldPos = `xform -q -ws -rp $obj`;\n\t\t\tmove -rpr 0 0 0 $obj;\n\t\t\tmakeIdentity -apply true -t 1 -r 0 -s 0 $obj;\n\t\t\txform -t ($worldPos.x) ($worldPos.y) ($worldPos.z) $obj;\n\t\t\tif ($parent != \"\") // reparent obj\n\t\t\t{\n\t\t\t\t$obj = getArrayItem0(`parent $obj $parent`);\n\t\t\t\t$obj = `rename $obj $shortName`;\n\t\t\t\treorder -front $obj;\n\t\t\t\treorder -relative $outlinerPosition $obj;\n\t\t\t}\n\n\t\t\t// put the children back under the object\n\t\t\tif (`size($children)`)\n\t\t\t{\n\t\t\t\tfor ($child in $children)\n\t\t\t\t{\n\t\t\t\t\t// reparent this child\n \t\t\t\t\t$child = getArrayItem0(`parent $child $obj`);\n\t\t\t\t\tvector $curPos =    `getAttr ($child + \".t\")`;\n\n\t\t\t\t\trelocateTransAnim($curPos, $child);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ($animCheck)\n\t\t\t{\n\t\t\t\tvector $curPos =    `getAttr ($obj + \".t\")`;\n\t\t\t\t// reinsert translation curve as it has been taken\n\t\t\t\tpasteKey $obj;\n\t\t\t\t\n\t\t\t\trelocateTransAnim($curPos, $obj);\n\t\t\t}\n\t\t\t// sometimes there is a very tiny restvalue so:\n\t\t\t// forcing local pivot to 0 0 0\n\t\t\txform -rp 0 0 0 $obj;\n\t\t\txform -sp 0 0 0 $obj;\n\n\t\t\t// final test\n\t\t\t$localPivot = `xform -q -rp $obj`;\n\t\t\tif ($localPivot == <<0,0,0>>)\n\t\t\t\tprint (\"resetPivot (\" + $count++ + \"): \\\"\" + $shortName + \"\\\" fixet! No offset anymore!\\n\");\n\t\t\telse\n\t\t\t\twarning (\"\\\"\" + $shortName + \" has still an offset!!\");\n\t\t}\n\t\telse\n\t\t\tprint (\"resetPivot (\" + $count++ + \"): pivot of \"+$shortName+\" not dirty! Skipped!\\n\");\n\t}\n\tselect -r $sel;\n}\nresetPivot()" 
        -sourceType "mel" 
        -commandRepeatable 1
        -flat 1
    ;
    shelfButton
        -enableCommandRepeat 1
        -enable 1
        -width 35
        -height 35
        -manage 1
        -visible 1
        -preventOverride 0
        -annotation "turns blandshape to bone animation" 
        -enableBackground 0
        -backgroundColor 0 0 0 
        -highlightColor 0.321569 0.521569 0.65098 
        -align "center" 
        -label "//this script puts locators under vertices\n//then puts bones und..." 
        -labelOffset 0
        -rotation 0
        -flipX 0
        -flipY 0
        -useAlpha 1
        -font "plainLabelFont" 
        -imageOverlayLabel "blend2bone" 
        -overlayLabelColor 0.8 0.8 0.8 
        -overlayLabelBackColor 0 0 0 0.5 
        -image "C:/Users/jef/Documents/maya/2018/prefs/icons/blendshape2bones_icon.png" 
        -image1 "C:/Users/jef/Documents/maya/2018/prefs/icons/blendshape2bones_icon.png" 
        -style "iconOnly" 
        -marginWidth 1
        -marginHeight 1
        -command "//this script puts locators under vertices\n//then puts bones under those locators\n\n\n\n//get selection\nstring $selectedPoly[] = `ls -sl`;\nint $selSize = size($selectedPoly);\nint $selected = 1;\nint $numberOfBlendShapes;\nint $doit = 1;\nstring $myBlendShapeList[];\n\n\n\n//check selection\nif ($selSize == 0)\n{\n    $selected = 0;\n}\n//check for blendShapes\n//if ($selSize != 0)\n//{\n    string $hist[] = `listHistory $selectedPoly[0]`;\n    select -r $hist;\n    $myBlendShapeList = `ls -sl -type blendShape`;\n    $numberOfBlendShapes = size($myBlendShapeList);\n//}\n\n\n\nif ($numberOfBlendShapes == 0)\n{\n    $selected = 0;\n}\n\n\n\nif ($selected == 0)\n{\n    confirmDialog -title \"You're givin' me nuthin here!\"\n    -message \"No blendshape is selected. Select your animated blendshape, then run the script again to create a bone rigged version of it.\"\n    -button \"Ok\";\n}\nelse\n{\n//get vert count\nint $numberOfVerts[] = `polyEvaluate -v $selectedPoly[0]`;\n\n\n\n\nif ($numberOfVerts[0] > 255)\n{\n    string $buttonPush = `confirmDialog -title \"Playcanvas No Likey!\"\n    -message \"The resulting skeleton from this blendshape will exceed the 256 bone limit Playcanvas has for joint chains, so it will NOT work in Playcanvas\"\n    -button \"Run It Anyway!\"\n    -button \"Cancel\"\n    -cancelButton \"Cancel\"\n    -defaultButton \"Run It Anyway!\"`;\n\n\n\n    if ($buttonPush == \"Cancel\")\n    {\n        $doit = 0;\n    }   \n}\n\n\n\nif ($doit == 1)\n{\n\n\n\n//get how many digits the vert count is\nstring $vertNum = $numberOfVerts[0];\nint $vertDigits = size($vertNum);\n\n\n\n//create parent node for locators\nstring $locParent = `group -em -n \"vertLocs_grp\"`;\n\n\n\n//create variable to hold locator names\nstring $locatorNames[];\n\n\n\n///////////////////////////////////////////////////\n//loop to create and constrain locators to vertices\n///////////////////////////////////////////////////\n\n\n\nfor( $q=0; $q<$numberOfVerts[0]; ++$q )\n{\n    //get padded version of $q\n    string $index = $q;\n    int $indexSize = size($index);\n    int $padding = ($vertDigits - $indexSize);\n    string $paddedIndex = $index;\n    for( $p=0; $p<$padding; ++$p )\n    {\n        $paddedIndex = (\"0\" + $paddedIndex);\n    }\n    \n    //get name of current vertex\n    string $currentVertName = ($selectedPoly[0] + \".vtx[\" + $q + \"]\");\n    float $vertPos[] = `xform -q -ws -t $currentVertName`;\n    \n    //create locator\n    string $locName[] = `spaceLocator -n ($selectedPoly[0] + \"_\" + $paddedIndex + \"_locator\")`;\n    parent $locName[0] $locParent;\n\n\n\n    //constrain locator to vertex\n    select -r $currentVertName;\n    select -add $locName[0];\n    pointOnPolyConstraint;\n\n\n\n    //add to array with locator names\n    $locatorNames[size($locatorNames)] = $locName[0]; \n}\n\n\n\n////////////////////////////////////////\n//create loop to put joints under verts\n////////////////////////////////////////\n\n\n\n//create base joint\nselect -cl;\nstring $baseJoint = `joint -n \"baseJoint#\" -p 0 0 0`;\nstring $origGeoConstName[] = `parentConstraint $selectedPoly[0] $baseJoint`;\ndelete $origGeoConstName;\n\n\n\n//get origianl object's parent and put base joint under it\nstring $mainObjectParent[] = `listRelatives -parent $selectedPoly[0]`;\nif (size($mainObjectParent)>0)\n{\nparent $baseJoint $mainObjectParent[0];\n}\n//loop to put joints under base joint and constrain them to locator\nstring $jointList[];\nstring $constList[];\n\n\n\nfor( $r=0; $r<$numberOfVerts[0]; ++$r )\n{\n    //get current vertex name and get position\n    string $currentVertName = ($selectedPoly[0] + \".vtx[\" + $r + \"]\");\n    float $currentVertPos[] = `xform -q -ws -t $currentVertName`;\n\n\n\n    //create joint\n    string $jointName = ($locatorNames[$r] + \"_JNT\");\n    select -cl;\n    select $baseJoint;\n    $newJoint = `joint -n $jointName -p $currentVertPos[0] $currentVertPos[1] $currentVertPos[2]`;\n    //constrain joint to locator\n    string $constName[]= `parentConstraint $locatorNames[$r] $newJoint`;\n    select -cl;\n    $jointList[size($jointList)] = $newJoint;\n    $constList[size($constList)] = $constName[0];\n    \n}\n\n\n\n//get keyframes from blend animation to bake out joints\n\n\n\n\nint $lowKey;\nint $highKey;\n\n\n\nfor($t=0; $t<$numberOfBlendShapes; ++$t)\n{\n    float $keyTimes[] = `keyframe -q $myBlendShapeList[$t]`;\n    int $keyCount = size($keyTimes);\n    \n    if ($keyCount > 0)\n    {\n        int $firstKey = $keyTimes[0];\n        int $lastKey = $keyTimes[$keyCount-1];\n    \n        $lowKey = $firstKey;\n        $highKey = $lastKey;\n        print (\"low = \" + $lowKey + \"\\n\");\n        print (\"high = \" + $highKey + \"\\n\");\n\n\n\n        if ($keyCount > 0)\n        {        \n            if ($lowKey > $firstKey)\n            {\n                $lowKey = $firstKey; \n            }\n            if ($highKey < $lastKey)\n            {\n                $highKey = $lastKey;\n            }\n           \n        }\n    }\n   \n}\n\n\n\n///////////////////////////////////////////\n//bake out joints and delete helper objects\n///////////////////////////////////////////\n\n\n\n//get animation from original object and apply it to the base joint\nfloat $objAnim[] = `keyframe -q $selectedPoly[0]`;\nint $animExists = size($objAnim);\nif ($animExists > 0)\n{\n    copyKey $selectedPoly[0];\n    pasteKey $baseJoint;\n}\n\n\n\n//move time to beginning of animation\ncurrentTime $lowKey;\n\n\n\nstring $timeText = ($lowKey + \":\" + $highKey);\n\n\n\nselect -r $jointList;\nselect -add $baseJoint;\nbakeResults -simulation true -t $timeText -sb 1 -at tx -at ty -at tz -at rx -at ry -at rz;\ndelete $constList;\n//delete $locatorNames;\ndelete $locParent;\n\n\n\n//////////////////////////////////////////////////////\n//duplicate original object and skin it to created bones\n//////////////////////////////////////////////////////\n\n\n\nstring $dupName = ($selectedPoly[0] + \"_rigged\");\nstring $newGeo[] = `duplicate -n $dupName $selectedPoly[0]`;\nparent -world $newGeo[0];\n\n\n\n//skin it\nselect -r $newGeo[0];\nselect -add $baseJoint;\nstring $clusterName[] = `skinCluster -mi 1 -omi true`;\n\n\n\n/////////////////\n//Weight Paint\n/////////////////\nint $jointSize = size($jointList);\nstring $vertName;\n\n\n\nfor($u=0; $u<$jointSize; ++$u)\n{\n    $vertName = ($dupName + \".vtx[\" + $u + \"]\");\n    skinPercent -transformValue $jointList[$u] 1 $clusterName[0] $vertName;\n}\n\n\n\nhide $selectedPoly[0];\n}\n};\n\n\n" 
        -sourceType "mel" 
        -commandRepeatable 1
        -flat 1
    ;
    shelfButton
        -enableCommandRepeat 1
        -enable 1
        -width 35
        -height 35
        -manage 1
        -visible 1
        -preventOverride 0
        -annotation "Sets animation settings back to default" 
        -enableBackground 0
        -backgroundColor 0 0 0 
        -highlightColor 0.321569 0.521569 0.65098 
        -align "center" 
        -label "//////////////////////\n//Return Animation Settings changed by Pl..." 
        -labelOffset 0
        -rotation 0
        -flipX 0
        -flipY 0
        -useAlpha 1
        -font "plainLabelFont" 
        -imageOverlayLabel "defaults" 
        -overlayLabelColor 0.8 0.8 0.8 
        -overlayLabelBackColor 0 0 0 0.5 
        -image "C:/Users/jef/Documents/maya/2016/prefs/icons/finish_flags.png" 
        -image1 "C:/Users/jef/Documents/maya/2016/prefs/icons/finish_flags.png" 
        -style "iconOnly" 
        -marginWidth 1
        -marginHeight 1
        -command "//////////////////////\n//Return Animation Settings changed by Playcanvas script to default\n//////////////////////\ncurrentUnit -t film;\nkeyTangent -global -itt auto -ott auto;\n//Sets playback bar to 1\nplaybackOptions -e -min 1 -max 120 -ast 1 -aet 200;\n//sets playback to frame start\nplayButtonStart;" 
        -sourceType "mel" 
        -commandRepeatable 1
        -flat 1
    ;
    shelfButton
        -enableCommandRepeat 1
        -enable 1
        -width 35
        -height 35
        -manage 1
        -visible 1
        -preventOverride 0
        -annotation "puts UV layout onto specified quadrant" 
        -enableBackground 0
        -backgroundColor 0 0 0 
        -highlightColor 0.321569 0.521569 0.65098 
        -align "center" 
        -label "string $selected;\nstring $radioBtnGrpName;\nstring $windowName;\ns..." 
        -labelOffset 0
        -rotation 0
        -flipX 0
        -flipY 0
        -useAlpha 1
        -font "plainLabelFont" 
        -imageOverlayLabel "4atlas-er" 
        -overlayLabelColor 0.8 0.8 0.8 
        -overlayLabelBackColor 0 0 0 0.5 
        -image "commandButton.png" 
        -image1 "commandButton.png" 
        -style "iconOnly" 
        -marginWidth 1
        -marginHeight 1
        -command "string $selected;\nstring $radioBtnGrpName;\nstring $windowName;\nstring $sel[] = `ls -sl`;\n\nproc reMapUV(string $selected, string $radioBtnGrpName, string $windowName, string $sel[])\n{\n    \n    $selected = `radioButtonGrp -query -select $radioBtnGrpName`;\n    //print ($selected + \"\\n\");\n    deleteUI -window $windowName;\n    \n    //print $sel;\n    int $selSize = size($sel);\n    \n    //for loop for each selected object\n    for ( $i=0; $i<$selSize; ++$i )\n    {\n        select -r $sel[$i];\n        int $numberUV[] = `polyEvaluate -uv $sel[$i]`;\n        print (\"UV count = \" + $numberUV[0] + \"\\n\");\n\n            //create loop for each UV\n            for ( $j=0; $j<$numberUV[0]; ++$j )\n            {\n                string $uvName = ($sel[$i] + \".map[\" + $j + \"]\");\n                select -r $uvName;\n                float $current_Uval[] = `polyEditUV -r false -q`;\n                //print (\"the U value for \" + $uvName + \"is: \" + $current_Uval[0] + \"\\n\");\n                //print (\"the V value for \" + $uvName + \"is: \" + $current_Uval[1] + \"\\n\");\n                \n                //adjust according to which quadrant\n                if ($selected == 1)\n                {\n                    //print (\"top Left\" + \"\\n\");\n                    float $newUval = $current_Uval[0]/2;\n                    float $newVval = ($current_Uval[1]/2) + .5;\n                    polyEditUV -r false -u $newUval -v $newVval;\n                }\n                if ($selected == 2)\n                {\n                    //print (\"Top Right\" + \"\\n\");\n                    float $newUval = ($current_Uval[0]/2) + .5;\n                    float $newVval = ($current_Uval[1]/2) + .5;\n                    polyEditUV -r false -u $newUval -v $newVval;\n            \n                }\n                if ($selected == 3)\n                {\n                    //print (\"Bottom Left\" + \"\\n\");\n                    float $newUval = $current_Uval[0]/2;\n                    float $newVval = $current_Uval[1]/2;\n                    polyEditUV -r false -u $newUval -v $newVval;\n                            \n                }\n                if ($selected == 4)\n                {\n                    //print (\"Bottom Right\" + \"\\n\");\n                    float $newUval = ($current_Uval[0]/2) + .5;\n                    float $newVval = $current_Uval[1]/2;\n                    polyEditUV -r false -u $newUval -v $newVval;\n\n                }\n                \n                //select -cl;\n            }\n\n    \n       \n    }\n    \n}\n\n$windowName = `window -h 100 -w 318 -title \"ReMapUV\"`;\ncolumnLayout;\n$radioBtnGrpName = `radioButtonGrp -numberOfRadioButtons 4\n    -label \"Quadrant:\" -labelArray4 \"Top Left\" \"Top Right\" \"Bottom Left\" \"Bottom Right\"`;\n    radioButtonGrp -edit -select 1 $radioBtnGrpName;\ncolumnLayout;\nrowColumnLayout -nc 2 -cw 1 350 -cw 2 350;\n   button -label \"Remap UV\" -command \"reMapUV($selected, $radioBtnGrpName, $windowName, $sel)\";\n   button -label \"Close/Cancel\" -command (\"deleteUI -window \" + $windowName);\n showWindow $windowName;" 
        -sourceType "mel" 
        -commandRepeatable 1
        -flat 1
    ;
    shelfButton
        -enableCommandRepeat 1
        -enable 1
        -width 34
        -height 34
        -manage 1
        -visible 1
        -preventOverride 0
        -annotation "put locator at selected objects" 
        -enableBackground 0
        -backgroundColor 0 0 0 
        -highlightColor 0.321569 0.521569 0.65098 
        -align "center" 
        -label "//put loc at each object\nstring $mySel[] = `ls -sl`;\nint $selSiz..." 
        -labelOffset 0
        -rotation 0
        -flipX 0
        -flipY 0
        -useAlpha 1
        -font "plainLabelFont" 
        -imageOverlayLabel "locs" 
        -overlayLabelColor 0.8 0.8 0.8 
        -overlayLabelBackColor 0 0 0 0.5 
        -image "commandButton.png" 
        -image1 "commandButton.png" 
        -style "iconOnly" 
        -marginWidth 1
        -marginHeight 1
        -command "//put loc at each object\nstring $mySel[] = `ls -sl`;\nint $selSize = size($mySel);\nint $k;\nif ($selSize > 0)\n{\nfor( $k=0; $k<$selSize; ++$k )\n{\n    string $name = ($mySel[$k] + \"_locator\");\n    string $locName[] = `spaceLocator -n $name`;\n    string $constName[] = `parentConstraint $mySel[$k] $locName`;\n    delete $constName; \n};\n}\n" 
        -sourceType "mel" 
        -commandRepeatable 1
        -flat 1
    ;

} 
